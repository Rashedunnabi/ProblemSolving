{
	"SegmentTree_Snippet": {
		"prefix": "SegmentTree",
		"body": [
		  "const int N = 1e5 + 2, MOD = 1e9 + 7;",
		  "int tree[4 * N], a[N];",
		  "void build(int node, int st, int en)",
		  "{",
		  "    if (st == en)",
		  "    {",
		  "        tree[node] = a[st];",
		  "        return;",
		  "    }",
		  "",
		  "    int mid = (st + en) / 2;",
		  "    build(2 * node, st, mid);",
		  "    build(2 * node + 1, mid + 1, en);",
		  "    //operation",
		  "    tree[node] = tree[2 * node] + tree[2 * node + 1];",
		  "}",
		  "",
		  "int query(int node, int st, int en, int l, int r)",
		  "{",
		  "    if (en < l || st > r)",
		  "    {",
		  "        return 0;",
		  "    }",
		  "",
		  "    if (l <= st && en <= r)",
		  "        return tree[node];",
		  "",
		  "    int mid = (st + en) / 2;",
		  "    int q1 = query(2 * node, st, mid, l, r);",
		  "    int q2 = query(2 * node + 1, mid + 1, en, l, r);",
		  "    ",
		  "    //operation",
		  "    return q1 + q2;",
		  "}",
		  "",
		  "void update(int node, int st, int en, int idx, int val)",
		  "{",
		  "    if (st == en)",
		  "    {",
		  "        a[st] = val;",
		  "        tree[node] = val;",
		  "        return;",
		  "    }",
		  "",
		  "    int mid = (st + en) / 2;",
		  "    if (idx <= mid)",
		  "    {",
		  "        update(2 * node, st, mid, idx, val);",
		  "    }",
		  "    else",
		  "    {",
		  "        update(2 * node + 1, mid + 1, en, idx, val);",
		  "    }",
		  "    //operation",
		  "    tree[node] = tree[2 * node] + tree[2 * node + 1];",
		  "}",
		  " ",
		  "//before use segment tree build first",
		  "//build(1, 0, n - 1);",
		  "//update(1, 0, n - 1, idx, val); // a[idx]=val",
		  "//query(1, 0, n - 1, l, r);      // sum in range [l,r]",
		  "//Taking array input in a[i]",
		  "",
		  "   "
		],
		"description": "SegmentTree_Snippet"
	  }
}